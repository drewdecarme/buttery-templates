import { writeFile } from "node:fs/promises";
import path from "node:path";
import type { ButteryConfigBase, ButteryConfigDocsRemix } from "@buttery/core";
import { glob } from "glob";

import { readConfig } from "@remix-run/dev/dist/config.js";
import { createGraph } from "../util.createGraph";
import { LOG_DOCS } from "../util.logger";
import type { FileObj } from "../util.types";
import { getRemixFilename } from "./getRemixFileName";
import { getRemixRoutePath } from "./getRemixRoutePath";

function orderFiles({
  docsConfig: { navOrganization },
  files
}: { docsConfig: ButteryConfigDocsRemix; files: FileObj[] }): FileObj[] {
  if (!navOrganization) {
    LOG_DOCS.warning(
      "No navOrganization defined... will be outputting graph in order the files are processed."
    );
    return files;
  }

  const oFiles: FileObj[] = [];

  for (const section in navOrganization) {
    const sectionOrder = navOrganization[section].routeOrder;
    for (const sectionRoute of sectionOrder) {
      const orderedFilename = `${section}.${sectionRoute}`;
      const foundFile = files.find((file) => file.filename === orderedFilename);
      if (foundFile) oFiles.push(foundFile);
    }
  }
  for (const file of files) {
    const fileAlreadyOrdered = oFiles.find(
      (oFile) => oFile.filename === file.filename
    );
    if (!fileAlreadyOrdered && file.filename === "_index") {
      // add the _index file to the beginning of the order
      oFiles.unshift(file);
    } else if (!fileAlreadyOrdered) {
      // add the un ordered files to the end of the order
      LOG_DOCS.debug(
        `No order defined for "${file.filename}". Ordering arbitrarily.`
      );
      oFiles.push(file);
    }
  }
  return oFiles;
}

export async function buildRemix(
  baseConfig: ButteryConfigBase,
  docsConfig: ButteryConfigDocsRemix
): Promise<void> {
  const docsPrefix = docsConfig.docsPrefix ?? "_docs.";
  const remixConfig = await readConfig(baseConfig.root);
  const remixAppDir = remixConfig.appDirectory;
  const remixRoutesDir = path.join(remixAppDir, "/routes");

  const patterns = [
    `**/${docsConfig.docsPrefix}/**/*`,
    `**/${docsConfig.docsPrefix}.*`
  ].map((pattern) => path.resolve(remixRoutesDir, pattern));

  const rawFiles = await glob(patterns);
  const enrichedFiles = rawFiles.map((file) => {
    const fsPath = file;
    const filename = getRemixFilename(fsPath, docsPrefix);
    const routePath = getRemixRoutePath(filename);

    return {
      fsPath,
      filename,
      routePath
    };
  });
  const files = orderFiles({ docsConfig, files: enrichedFiles });

  // TODO: Put behind logging tag
  // console.log(files);

  const docsGraph = await createGraph({
    files,
    docsConfig
  });

  LOG_DOCS.debug("Creating resource route...");
  const resourceRoutePath = path.resolve(remixRoutesDir, "./api.docs.graph.ts");
  const resourceRouteContent = `// THIS FILE IS AUTO GENERATED BY \`@BUTTERY/DOCS\`. PLEASE DO NOT EDIT
import type { ButteryDocsGraph } from "@buttery/docs/types";
import { json } from "@remix-run/cloudflare";

const graph: ButteryDocsGraph = ${JSON.stringify(docsGraph, null, 2)}

/**
 * A loader that can either be imported as an alias and then re-exported
 * or straight up re-exported to be used in any route that only requires
 * the documentation graph
 */
export async function loader() {
  return json({ graph });
}

/**
 * A standalone function that fetches the graph from the loader that is defined
 * in this resource route.
 */
export async function getGraph(request: Request) {
  try {
    const requestURL = new URL(request.url);
    const res = await fetch(requestURL.origin.concat("/api/docs/graph"));
    const data = (await res.json()) as ButteryDocsGraph;
    return data;
  } catch (error) {
    throw new Response(
      \`There was an error when trying to fetch the documentation graph: \${error}\`,
      { status: 500 }
    );
  }
}
`;
  await writeFile(resourceRoutePath, resourceRouteContent);
  LOG_DOCS.debug("Creating resource route... done.");
}
